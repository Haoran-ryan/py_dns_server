# py_dns_server

## DNS uses raw bi codes 

```python3
import socket

port = 53 # DNS operates on port 53 by default 
ip = "127.0.0.1" 

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port)) # bind takes 1 parameter 

while True:
    data, addr = sock.recvfrom(512)
    print(data)

```

use the dig in the terminal to mimic a dns query on 127.0.0.1 and the following is the output:
```
dns_server git:(main) ✗ sudo python3 dns.py
b'\x00\xcf\x01 \x00\x01\x00\x00\x00\x00\x00\x01\x07howcode\x03org\x00\x00\x01\x00\x01\x00\x00)\x10\x00\x00\x00\x00\x00\x00\x00'
b'\x00\xcf\x01 \x00\x01\x00\x00\x00\x00\x00\x01\x07howcode\x03org\x00\x00\x01\x00\x01\x00\x00)\x10\x00\x00\x00\x00\x00\x00\x00'
b'\x00\xcf\x01 \x00\x01\x00\x00\x00\x00\x00\x01\x07howcode\x03org\x00\x00\x01\x00\x01\x00\x00)\x10\x00\x00\x00\x00\x00\x00\x00'
```

## DNS header 

                                   1  1  1  1  1  1
      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                      ID                       |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    QDCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ANCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    NSCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |                    ARCOUNT                    |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

1. transactsionID - 16 bits / 2 Bytes | the response received comes from the server requested from
1. flags - 16b/2B in total
    1. QR - 1 bit | 0 query , 1 response 
    1. OPCODE - 4 bit 
        1. 0 standard query, ...
        1. from original `query` and copied into `response` 

## getquestiondomain 函数
让我们以处理域名 "www.google.com" 为例，对 `getquestiondomain` 函数进行分析。在 DNS 查询中，这个域名会被编码为 "\x03www\x06google\x03com\x00"。

1. 函数首先初始化一些变量：`state`、`expectedlen`、`domainstring`、`domainparts`、`x` 和 `y`。其中 `state` 是状态标志，用于表示我们当前是在读取标签长度还是标签内容。`expectedlen` 是我们期望的标签长度，`domainstring` 用于保存当前标签的内容，`domainparts` 用于保存所有的标签，`x` 用于追踪 `domainstring` 的长度，`y` 用于追踪已处理的字节数。

2. 函数开始遍历 `data` 中的每一个字节。首先，我们得到第一个字节，它的值是3，对应于 "\x03"。

3. 因为 `state` 初始值为0，所以我们进入 `else` 分支，将 `state` 设置为1，表示我们正在读取标签长度，并将 `expectedlen` 设置为当前字节的值，即3。然后 `x` 和 `y` 都增加1。

4. 接下来的三个字节是 "www"。因为 `state` 现在是1，我们进入 `if` 分支，将每个字节转换为字符并添加到 `domainstring`。每处理一个字节，`x` 和 `y` 都会增加1。当 `x` 等于 `expectedlen` 时，我们知道我们已经读取完一个标签，所以我们将 `domainstring` 添加到 `domainparts`，然后重置 `domainstring` 和 `state`，准备读取下一个标签。

5. 我们重复步骤3和4，读取剩下的标签 "google" 和 "com"。

6. 最后，我们得到一个字节 "\x00"，它表示域名的结束。我们将最后一个 `domainstring` 添加到 `domainparts`，然后退出循环。

7. 在循环结束后，我们已经处理完整个域名部分，`y` 指向了 "\x00"。然后我们提取查询类型为 `data[y+1:y+3]`，这个查询类型就是紧跟在域名后面的两个字节。

8. 最后，函数返回一个元组，包含 `domainparts`（一个包含所有标签的列表）和查询类型。

## `\x`转移序列
我理解你的疑问。在Python中，`\x03` 看起来确实有四个字符，但实际上它表示的是一个单一的字节。这是因为 `\x` 是一个转义序列，它表示接下来的两个字符应该被解释为一个单一的字节，这个字节的值由这两个字符表示的十六进制数决定。 

因此，`\x03` 是一个字节，它的值是3。同样地，`\x00` 是一个字节，它的值是0，`\x0A` 是一个字节，它的值是10，等等。

在我们的例子中，当我们说 "www.google.com" 被编码为 `\x03www\x06google\x03com\x00`，我们是说这个字符串由以下的字节组成：

- 一个字节，值为3，表示接下来的标签长度（"www"）；
- 三个字节，分别是 "w"、"w"、"w"；
- 一个字节，值为6，表示接下来的标签长度（"google"）；
- 六个字节，分别是 "g"、"o"、"o"、"g"、"l"、"e"；
- 一个字节，值为3，表示接下来的标签长度（"com"）；
- 三个字节，分别是 "c"、"o"、"m"；
- 一个字节，值为0，表示域名的结束。

### 对`\x03`的遍历？
在Python中，当我们对单个字节（如`\x03`）进行遍历时，我们实际上是在遍历一个只有一个元素的字节字符串。在这个情况下，我们会得到一个单独的字节，其值是3。我们不会分别得到`\`、`x`、`0`和`3`。

这是因为`\x03`实际上是一个字节的值，而不是由四个字符`\`、`x`、`0`和`3`组成的字符串。

让我们通过一个简单的Python代码片段来解释这一点：

```python
data = b'\x03'
for byte in data:
    print(byte)
```

这段代码会打印出单独的数字`3`，而不是`\`、`x`、`0`和`3`。

在Python中，`b` 前缀表示字节字符串。字节字符串是由单个字节组成的序列，这与普通字符串不同，普通字符串是由字符组成的。

每个字节都是0到255之间的整数，可以用于表示ASCII字符或二进制数据。例如，`b'hello'` 是一个字节字符串，包含五个字节：104, 101, 108, 108, 111（这些是字符'h', 'e', 'l', 'l', 'o'的ASCII值）。

在你的DNS服务器代码中，你会接收到一个字节字符串，这个字节字符串包含了DNS查询的所有数据。你需要按照DNS协议的规定来解析这个字节字符串，这就是为什么你需要处理字节字符串，而不是普通的字符串。

这就是为什么在你的`getquestiondomain`函数中，当你对`data`进行遍历时，你是在按字节处理数据，每个`byte`都是一个0到255之间的整数，而不是单个字符。

## Python位操作和掩码在处理二进制数据中的应用

### 问题
在Python中处理DNS协议消息头部标志字段时，为何要用到位操作和掩码？

### 常见误区
* 误解1: 我们可以直接通过比较操作（如==1）来检查一个字节中特定位置的位的值。
* 误解2: “1”只是一个位的值，没有特殊含义。

### 解答
1. **位操作和掩码的概念：**
   * 在Python等编程语言中，位操作可以直接在二进制级别上处理数据。掩码（Mask）是一种常见的位操作技术，通常用于控制或检查某个数值中的特定位。
2. **为何使用位操作：**
   * 在处理网络协议或其他包含复杂位字段的数据结构时，位操作是一个非常有用的工具。例如，在DNS协议中，头部的"标志"字段中每一位都有特定的含义。因此，我们需要用到位操作来检查或设置这些特定位置的位的值。
3. **为何使用掩码：**
   * 掩码用于生成一个二进制数字，这个数的二进制表示中只有一个位是1（位置由我们自己决定），其余位都是0。然后，我们将这个掩码和目标字节进行位与操作，这样可以检查目标字节在特定位置上的位是否是1。这是一种高效的方式来检查一个字节中特定位置的位的值，无需将整个字节转换为其他格式（如字符串或整数）。
4. **"1"和"0"的含义：**
   * 在处理二进制数据时，"1"和"0"不仅仅是位的值，他们实际上代表了信息。每一位在字节中的位置，都可能有特定的含义。因此，我们需要检查特定位置的位是否为1或0，以解码包含在那个字节中的信息。

## 16进制和2进制
计算机在底层确实是以二进制的形式来存储和处理信息的。但在人类和计算机之间进行交流时，我们通常会使用更方便的表示方法。

使用十六进制的原因主要是出于方便性和效率的考虑。十六进制（base-16）是二进制（base-2）的一个很好的表示方式，因为每一个十六进制的数字可以精确地表示4个二进制位（称为一个二进制位元组）。这使得十六进制非常适合用来简洁地表示二进制数据。

例如，二进制的 1101 1011 可以更简洁地表示为十六进制的 DB。相比之下，如果你用二进制来表示，需要8个字符（1s and 0s），而十六进制只需要2个字符（D和B）。这就减少了我们需要书写和阅读的字符数量，使得大量的二进制数据更易于人类理解和处理。

再举一个实际的例子，像在网络编程中，IP地址、MAC地址等都经常用十六进制来表示，因为这样可以使长串的二进制数据更为简洁和清晰。

所以，虽然计算机在底层使用二进制，但在编程和其他需要处理大量数据的场景中，我们通常会使用其他的表示方法，如十六进制，来提高我们的效率。